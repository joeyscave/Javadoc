## 7.1 处理错误

### 7.1.1 异常分类

1. 所有的异常都是由Throwable继承而来：

   <img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210725000928100.png" alt="image-20210725000928100" style="zoom:80%;" />

+ Error : 运行时系统的内部错误和资源耗尽错误。不应该抛出此类错误。
+ Exception : 
  + RuntimeException : 由编程错误导致的异常
    + 错误的强制类型转换
    + 数组访问越界
    + 访问null指针
  + IOException : 不是由编程错误导致的其他异常
    + 试图超越文件末尾继续读取数据
    + 试图打开一个不存在的文件
    + 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在

2. 非检查型(unchecked)异常：Error或RuntimeException			检查型异常：IOException
3. 编译器将检查是否为所有检查型异常提供了异常处理器

### 7.1.2 声明检查型异常

1. 应该抛出检查型异常，而不应该抛出非检查型异常（Error无法处理，RuntimeException应该通过修改代码解决，而不是用捕捉异常处理）

2. 子类抛出的异常只能是父类抛出的异常的子类，或者干脆没有。（通过多态来解释）
3. 在子类的构造器中必须声明父类的构造器中抛出的所有异常（因为子类的构造器中调用了父类的构造器）

### 7.1.3 如何抛出异常

如果一个已有的异常类能够满足要求：

1. 找到一个合适的异常类
2. 创建这个类的一个对象
3. 将对象抛出

```java
String function() throw EOFException{
    ...
        throw new EOFException;
}
```

### 7.1.4 创建异常类

自定义的异常类应该包含两个构造器，一个默认构造器，一个包含详细信息的构造器 

```java
class MyException extends IOException{
    public MyException(){}
    public MyException(String gripe){
        super(gripe);
    }
}
```

## 7.2 捕获异常

### 7.2.1 捕获异常

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210725193728967.png" alt="image-20210725193728967" style="zoom:80%;" />

> “所处”指的是触发异常语句所处的最小代码块（最邻近的一对大括号）

### 7.2.2 捕获多个异常

```java
e.getMessage();	//获得异常对象的更多信息
e.getClass().getName();	//获得异常对象的实际类型

catch(FirstException | SecondException e){}	
//若多个没有子类关系的异常用的是同样处理方式，可以用这样的语句一次性捕获多个异常
//捕获多个异常时，异常变量e隐含为final变量，不能改变
```

### 7.2.3 再次抛出异常与异常链

再次抛出异常（异常包装技术）：在catch子句中throw一个异常

1. 可以用于封装子系统的具体异常原因（捕获具体异常，再在catch中抛出一个更高层的异常，这样主系统只需要知道这个子系统出现了异常）

   ```java
   try{
       ...
   }
   catch(SQLException original){
       var e=new ServletException("database error");	//构造并指定异常的message
       e.initialCause(original);	//指定造成异常的cause
       throw e;
   }
   
   //主系统捕捉到这个被重新抛出的异常时，可以这样获取原始异常
   Throwable original=caughtException.getcause();
   ```

2. 如果一个方法不允许抛出某个异常，可以利用这种包装技术把原始异常包装成另外的异常

### 7.2.4 finally子句

1. fianlly子句解决的问题：由于抛出异常导致方法中途退出，使得一些资源没有正常关闭的问题
2. fianlly子句是一个基本的概念，实际上还是以使用try-with-Resources为主

```java
var in=new FileInputStream(...);
try{
    //1
    throw exception;
    //2
}
catch(...){
    //3
    throw exception;
    //4
}
finally{
    //5
    in.close();
}
//6
```

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210730135055892.png" alt="image-20210730135055892" style="zoom:80%;" />

3. 可以没有catch语句使用fianlly语句
4. 可以使用try语句嵌套，内层try-finally，外层try-catch来保证资源关闭
5. finally语句应该用来关闭资源，而不应包含任何改变控制流程的语句（例如return，throw，break等）

### 7.2.5 try-with-Resources语句

```java
try (Resorce res=...){
    //work with res
}
```

1. 如果res实现了AutoCloseable接口，try抛出异常或正常结束后都会执行res.close()

2. 可以指定多个资源

   ```java
   try(var in=...;var out=...){}
   ```

3. 可以直接提供之前声明的事实最终变量

   ```java
   try(out){}
   ```

4. 如果try块和close方法都抛出异常，后者将会被"抑制"，并用addSurpress方法添加到原来的异常，可以用getSurpress方法调用它

5. try-with-Resources语句也可以有catch，可以有finally，这些语句将在资源被关闭后执行

### 7.2.6 分析堆栈轨迹元素

先过了777

## 7.3 使用异常的技巧

1. 异常处理不能代替简单测试

   > 可以用if语句或者其他简单测试避免的异常不要用异常捕捉机制来写，因为后者运行时间远远大于前者

2. 在不影响逻辑的前提下，尽量将正常处理(try)与错误处理(catch)分开来

3. 充分利用异常层次结构

4. 不要因为反感编译时会报错而暂时用空的catch语句忽略异常

5. 早抛出，晚捕获

## 7.4 使用断言

### 7.4.1 断言的概念

```java
assert condition:expression;	//expression为字符串，传递需要打印的错误信息
assert x>=0;"x小于0了"+x;	//自动把x对象转化为字符串
```

1. 断言用于调试，不能替代异常起到维护程序安全的作用
2. idea中启用断言运行：右上角编辑配置---添加VM选项---输入-ea

### 7.4.2 启用和禁用断言

主要是一些命令行指令，-ea(enableAssert)表示启用断言，-da(disableAssert)表示禁用断言

### 7.4.3 使用断言完成参数检查

过了777

### 7.4.4 使用断言提供假设文档

过了777

## 7.5 日志

### 7.5.1 基本日志

```java
Logger.getGlobal().info("something");	//利用全局记录器快速生成一条日志
Logger.getGlobal().setLevel(Level.OFF);	//在适当的地方(比如在main的最前面)，可以利用全局记录器取消所有日志
```

### 7.5.2 高级日志

先过了777

