## 9.1 集合框架

### 9.1.1 集合接口与实现分离

1. 队列既可以用循环数组实现，也可以用链表实现，但无论用哪种方式实现，队列类所包含的成员方法都是一样的，因此可以定义一个队列接口，所有的队列类都来实现这个接口即可。这样做的好处是：

   ```java
   var a=new CircularArrayQueue<String>(100);	
   ......	//如果发现使用链表队列比使用数组队列性能更高
       
   var a=new LinkedListQueue<String>(100);
   ......	//只需要改变构造器就行了，因为实现的是同一个接口，方法都一样，所以后面不用改
   ```

2. Abstract开头的类，是为用户自定义需要而设计的库类，实现Abstract类比直接实现接口要方便

### 9.1.2 Collection接口

集合类(数学中的集是set)的基本接口是Collection接口，这个接口有两个基本方法：

```java
boolean add(E element)	//添加元素确实改变了集合则返回true，未改变返回false(比如向集set中添加已有的元素)
Iterator<E> iterator();	//返回一个用于遍历的迭代器
```

### 9.1.3 迭代器

迭代器接口包含四个方法：

```java
E next();	//返回下一个元素，如果已经到末尾，抛出NoSuchElementException异常
boolean hasNext(); //判断后面还有没有元素
void remove();	//移除迭代器上一个访问的元素
default void forEachRemaining(Conmsumer <? super E> action); //提供一个lamda表达式，该方法将对每一个元素应用该表达式
```

777

1. next与hasNext配合使用

2. for each循环可以处理任何实现了Iterator接口的类

3. 可以认为迭代器位于两个元素之间

   <img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210808140057123.png" alt="image-20210808140057123" style="zoom:50%;" />

4. remove方法将删除刚刚越过的元素，如果刚刚调用了previous方法，这意味着将删除迭代器后面的一个元素

5. 不能连续调用remove方法（会抛出IlleagalStateException方法）

### 9.1.4 泛型实用方法

777

## 9.2 集合框架中的接口

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210808141650816.png" alt="image-20210808141650816" style="zoom:80%;" />

1. ListIterator是Iterator的一个子接口，定义了add方法在迭代器前面增加一个元素，可以连续调用
2. RandomAccess是一个标记接口，用来标记一个集合是否支持高效的随机访问
3. NavigableSet和NavigableMap包含一些用于搜索和遍历有序集和映射的方法

## 9.3 具体集合

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210808151124567.png" alt="image-20210808151124567" style="zoom:80%;" />

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210808151314369.png" alt="image-20210808151314369" style="zoom:80%;" />

### 9.3.1 链表

1. LInkedLIst.add方法只能把元素添加到链表尾部，要想添加到中间，要使用迭代器的add方法

2. ListIterator有两个方法用来反向遍历链表：

   ```java
   E previous()	//迭代器前移一位，并返回刚刚经过的元素
   boolean hasPrevious()	//判断前面是否还有元素
   ```

3. set方法会用提供的新元素替换刚刚用next或previous访问的文素

4. 如果迭代器检测到它的集合被另外的迭代器进行结构性修改（具体实现为检查自己的更改操作数与集合的更改操作数是否一致），就会抛出一个ConCurrent Modification异常

5. set方法不被视为结构性修改

6. 不要使用“虚假”的随机访问方法来遍历列表

   ```java
   for (int i=0;i<list.size();i++){
       do something with list.get(i);	//这段代码效率极低
   }
   ```

7. 链表迭代器的nextIndex方法返回下一个元素的索引，previous方法返回上一个元素的索引

8. 需要对集合进行随机访问时，不要使用链表

### 9.3.2 数组列表

Vector类是同步的，ArrayList类不同步，前者会浪费大量时间在同步上，因此如果仅仅从一个线程访问，使用后者

### 9.3.3 散列集

> 基于散列表实现的集(HashSet)

1. 散列集对元素顺序无要求

2. 散列集使用散列方法提高了检索性能

   > 每个对象都实现了HashCode方法，用此方法根据对象状态得到相应的散列值（对象状态相当于哈希函数）。Java中散列表用链表数组实现（桶满时链表会变成平衡二叉树以提高性能），装填因子为0.75，超过75%的桶满时则进行再散列

   <img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210808175540147.png" alt="image-20210808175540147" style="zoom:80%;" />

### 9.3.4 树集

树集(TreeSet)是一个有序集合，需要对象实现Comparable接口，或者在构造树集时提供一个比较器

### 9.3.5 队列与双端队列

队列允许高效地在尾部添加元素，在头部删除元素。双端队列(Deque接口)则允许在头尾都高效地添加和删除元素。ArrayDeque和LinkedList都实现了这个接口

### 9.3.6 优先队列

1. 底层用堆来实现
2. remove操作一定是取走队列中最小的
3. 迭代不一定按序

## 9.4 映射

### 9.4.1 基本映射操作

1. 类库提供了两个通用实现：HashMap和TreeMap
2. 键不能重复，一个键不能对应两个值
3. get用键获取值，若没有检索到则返回null
4. getOrDefault若没有检索到返回设定的默认值
5. remove删除给定键对应元素，size方法返回映射中的元素数
6. forEach方法接受一个lamda表达式，对映射内每个键值对执行此表达式
7. put将键值对增加到映射中

### 9.4.2 更新映射条目

merge和putIfAbsent方法

